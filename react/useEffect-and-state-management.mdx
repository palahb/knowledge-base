# React useEffect and State Management Guide

A comprehensive guide covering React best practices for handling state updates, useEffect patterns, and cleanup operations.

## Table of Contents
- [Input Handling: onChange vs useEffect](#input-handling-onchange-vs-useeffect)
- [State Update Patterns](#state-update-patterns)
- [useEffect with Props and Multiple State Updates](#useeffect-with-props-and-multiple-state-updates)
- [Understanding useEffect Lifecycle](#understanding-useeffect-lifecycle)
- [Race Conditions in useEffect](#race-conditions-in-useeffect)
- [Cleanup in useEffect](#cleanup-in-useeffect)
- [Common Cleanup Scenarios](#common-cleanup-scenarios)

---

## Input Handling: onChange vs useEffect

### The Right Approach: Use onChange

**onChange is always better for input handling** because it:
- Provides immediate response to user interactions
- Follows React's event-driven philosophy
- Offers better performance (no extra renders)
- Gives you direct control over timing

```jsx
// ✅ Correct approach
const SearchInput = () => {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState([]);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    
    // Immediate validation and updates
    if (value.length < 2) {
      setSuggestions([]);
      return;
    }
    
    // Immediate filtering
    const filtered = allSuggestions.filter(item =>
      item.toLowerCase().includes(value.toLowerCase())
    );
    setSuggestions(filtered);
  };

  return (
    <input
      value={query}
      onChange={handleInputChange}
      placeholder="Search..."
    />
  );
};
```

### When useEffect is Acceptable for Inputs

Only use useEffect for **side effects**, not direct input handling:

```jsx
// ✅ useEffect for debounced API calls
useEffect(() => {
  if (query.length >= 2) {
    const timer = setTimeout(() => {
      fetchRemoteSuggestions(query);
    }, 300);
    return () => clearTimeout(timer);
  }
}, [query]);
```

### Performance Comparison

```jsx
// ❌ Poor performance - extra renders
const [value, setValue] = useState('');

useEffect(() => {
  // Runs AFTER render when value changes
  handleInputChange(value);
}, [value]);

// ✅ Better performance - immediate response
const handleChange = (e) => {
  const newValue = e.target.value;
  setValue(newValue);
  handleInputChange(newValue); // Runs immediately
};
```

---

## State Update Patterns

### Anti-Pattern: Using useEffect to Update State

**Avoid using useEffect to update one state based on another state.**

```jsx
// ❌ Bad: Multiple renders and complexity
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [fullName, setFullName] = useState('');

useEffect(() => {
  setFullName(`${firstName} ${lastName}`); // Extra render!
}, [firstName, lastName]);
```

### Better Approaches

#### 1. Derived State (Computed Values)

```jsx
// ✅ Best: Computed on every render
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');

// No separate state needed
const fullName = `${firstName} ${lastName}`;

const handleFirstNameChange = (e) => {
  setFirstName(e.target.value);
  // fullName automatically updates on next render
};
```

#### 2. useMemo for Expensive Calculations

```jsx
// ✅ For expensive computations
const [items, setItems] = useState([]);
const [filter, setFilter] = useState('');

const filteredItems = useMemo(() => {
  return items.filter(item => 
    item.name.toLowerCase().includes(filter.toLowerCase())
  );
}, [items, filter]);
```

#### 3. Update Multiple States Together

```jsx
// ✅ Single state update with all calculations
const [formData, setFormData] = useState({
  price: 0,
  quantity: 0,
  total: 0,
  tax: 0,
  finalAmount: 0
});

const handlePriceChange = (e) => {
  const price = parseFloat(e.target.value) || 0;
  const total = price * formData.quantity;
  const tax = total * 0.1;
  const finalAmount = total + tax;
  
  setFormData(prev => ({
    ...prev,
    price,
    total,
    tax,
    finalAmount
  }));
};
```

#### 4. useReducer for Complex State Logic

```jsx
// ✅ For complex interdependent state
const formReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_PRICE':
      const price = action.payload;
      const total = price * state.quantity;
      const tax = total * 0.1;
      return {
        ...state,
        price,
        total,
        tax,
        finalAmount: total + tax
      };
    default:
      return state;
  }
};

const [formData, dispatch] = useReducer(formReducer, initialState);
```

### When useEffect IS Appropriate

```jsx
// ✅ Side effects that don't affect rendering
useEffect(() => {
  // API calls
  fetchUserData(userId);
}, [userId]);

useEffect(() => {
  // Browser APIs
  document.title = `${productName} - My Store`;
}, [productName]);

useEffect(() => {
  // Debounced operations
  const timer = setTimeout(() => {
    saveToLocalStorage(formData);
  }, 1000);
  return () => clearTimeout(timer);
}, [formData]);
```

---

## useEffect with Props and Multiple State Updates

### When It's Acceptable

Using useEffect to update multiple states based on prop changes is acceptable in specific scenarios:

#### 1. Responding to Prop Changes with Complex State Updates

```jsx
// ✅ Reasonable - prop change triggers related state updates
const UserProfile = ({ userId }) => {
  const [userData, setUserData] = useState(null);
  const [userPreferences, setUserPreferences] = useState({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (userId) {
      // Reset states when userId changes
      setLoading(true);
      setError(null);
      setUserData(null);
      setUserPreferences({});
      
      fetchUserData(userId)
        .then(data => {
          setUserData(data.profile);
          setUserPreferences(data.preferences);
        })
        .catch(err => setError(err))
        .finally(() => setLoading(false));
    }
  }, [userId]);
};
```

#### 2. Form Initialization from Props

```jsx
// ✅ Good use case - initializing form when data arrives
const EditForm = ({ initialData }) => {
  const [formData, setFormData] = useState({});
  const [isModified, setIsModified] = useState(false);
  const [validationErrors, setValidationErrors] = useState({});

  useEffect(() => {
    if (initialData) {
      setFormData(initialData);
      setIsModified(false);
      setValidationErrors({});
    }
  }, [initialData]);
};
```

### Optimization Strategies

#### 1. Use useReducer for Complex Updates

```jsx
// ✅ Single dispatch for related updates
const userReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_START':
      return {
        ...state,
        loading: true,
        error: null,
        userData: null,
        userPreferences: {}
      };
    case 'FETCH_SUCCESS':
      return {
        ...state,
        loading: false,
        userData: action.payload.profile,
        userPreferences: action.payload.preferences
      };
    default:
      return state;
  }
};

const UserProfile = ({ userId }) => {
  const [state, dispatch] = useReducer(userReducer, initialState);

  useEffect(() => {
    if (userId) {
      dispatch({ type: 'FETCH_START' });
      // ... fetch logic
    }
  }, [userId]);
};
```

#### 2. Group Related State

```jsx
// ✅ Single state object for related data
const [userState, setUserState] = useState({
  data: null,
  preferences: {},
  loading: false,
  error: null
});

useEffect(() => {
  if (userId) {
    setUserState({
      data: null,
      preferences: {},
      loading: true,
      error: null
    });
    // ... fetch logic
  }
}, [userId]);
```

---

## Understanding useEffect Lifecycle

### The Complete Lifecycle

When dependencies change, React follows this order:

1. **Dependency Change Detected** → Run cleanup function from PREVIOUS effect
2. **Then** → Run new effect function  
3. **Component Unmount** → Run cleanup function

### Step-by-Step Example

```jsx
useEffect(() => {
  console.log('Effect running for userId:', userId);
  let cancelled = false;
  
  if (userId) {
    fetchData(userId).then(data => {
      console.log('Data received for userId:', userId, 'cancelled:', cancelled);
      if (!cancelled) {
        setData(data);
      }
    });
  }
  
  return () => {
    console.log('Cleanup running, setting cancelled=true for userId:', userId);
    cancelled = true;
  };
}, [userId]);
```

### Timeline Breakdown

**Initial Mount (userId = 1):**
```
1. Effect runs: "Effect running for userId: 1"
2. cancelled = false (for userId=1 request)
3. fetchData(1) starts...
```

**User Changes to userId = 2:**
```
4. CLEANUP FIRST: "Cleanup running, setting cancelled=true for userId: 1"
   - Sets cancelled=true for FIRST effect's closure
5. NEW EFFECT: "Effect running for userId: 2" 
   - New cancelled = false (for userId=2 request)
6. fetchData(2) starts...
```

**Requests Complete:**
```
7. fetchData(2) completes: "Data received for userId: 2, cancelled: false"
   - Updates state ✅
8. fetchData(1) completes: "Data received for userId: 1, cancelled: true"  
   - Does NOT update state ✅
```

### Closure Scopes

Each effect execution creates its own closure:

```jsx
// When userId = 1
useEffect(() => {
  let cancelled = false;  // Closure 1: cancelled for userId=1
  
  fetchData(1).then(data => {
    // This callback remembers Closure 1's cancelled variable
    if (!cancelled) { /* ... */ }
  });
  
  return () => {
    cancelled = true;  // Sets Closure 1's cancelled to true
  };
}, [1]);

// When userId = 2  
useEffect(() => {
  let cancelled = false;  // Closure 2: cancelled for userId=2 (separate!)
  
  fetchData(2).then(data => {
    // This callback remembers Closure 2's cancelled variable  
    if (!cancelled) { /* ... */ }
  });
  
  return () => {
    cancelled = true;  // Sets Closure 2's cancelled to true
  };
}, [2]);
```

---

## Race Conditions in useEffect

### What Are Race Conditions?

Race conditions occur when multiple async operations complete in an unpredictable order, potentially causing wrong data to be displayed.

### Example of the Problem

```jsx
// ❌ This CAUSES race conditions
useEffect(() => {
  if (userId) {
    setLoading(true);
    fetchData(userId).then(data => {
      setData(data);        // Problem: Always updates state
      setLoading(false);    // even if userId has changed
    });
  }
}, [userId]);
```

**The Problem Scenario:**
1. Component mounts with `userId = 1`
2. `fetchData(1)` starts (takes 2 seconds)
3. User quickly changes to `userId = 2` 
4. `fetchData(2)` starts (takes 1 second)
5. `fetchData(2)` completes first → sets data for user 2 ✅
6. `fetchData(1)` completes second → **overwrites with user 1 data** ❌

Result: UI shows user 1's data even though `userId = 2`!

### Solution 1: Cancellation Flag

```jsx
// ✅ This PREVENTS race conditions
useEffect(() => {
  let cancelled = false;  // Cleanup flag
  
  if (userId) {
    setLoading(true);
    fetchData(userId).then(data => {
      if (!cancelled) {     // Only update if effect is still valid
        setData(data);
        setLoading(false);
      }
    });
  }
  
  return () => {
    cancelled = true;      // Mark as cancelled when userId changes
  };
}, [userId]);
```

### Solution 2: AbortController

```jsx
// ✅ Modern approach with request cancellation
useEffect(() => {
  const abortController = new AbortController();
  
  if (userId) {
    setLoading(true);
    
    fetchData(userId, { signal: abortController.signal })
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        if (error.name !== 'AbortError') {
          setError(error);
          setLoading(false);
        }
      });
  }
  
  return () => {
    abortController.abort(); // Actually cancels the network request
  };
}, [userId]);
```

---

## Cleanup in useEffect

### Why Cleanup is Necessary

Even with empty dependency arrays, components can **unmount**. Without cleanup:
- Timers keep running after component unmounts
- Event listeners remain attached
- WebSocket connections stay open
- Memory leaks occur

### Example: Timer Without Cleanup

```jsx
// ❌ Memory leak - timer keeps running after unmount
const Timer = () => {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1); // Tries to update unmounted component!
    }, 1000);
    
    // No cleanup!
  }, []); // Empty array - runs once
  
  return <div>Count: {count}</div>;
};
```

### Example: Timer With Cleanup

```jsx
// ✅ Proper cleanup - timer stops when component unmounts
const Timer = () => {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
    
    return () => {
      clearInterval(interval); // Stops timer on unmount
    };
  }, []);
  
  return <div>Count: {count}</div>;
};
```

### Key Principle

**Empty dependency array ≠ No cleanup needed**

- Empty dependency array = "Run effect once when component mounts"
- Cleanup function = "Run when component **unmounts**"

---

## Common Cleanup Scenarios

### 1. Event Listeners

```jsx
// ✅ Window events
useEffect(() => {
  const handleResize = () => {
    setWindowWidth(window.innerWidth);
  };
  
  window.addEventListener('resize', handleResize);
  
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);

// ✅ Document events
useEffect(() => {
  const handleKeyPress = (e) => {
    if (e.key === 'Escape') {
      setModalOpen(false);
    }
  };
  
  document.addEventListener('keydown', handleKeyPress);
  
  return () => {
    document.removeEventListener('keydown', handleKeyPress);
  };
}, []);
```

### 2. Timers and Intervals

```jsx
// ✅ Timeouts
useEffect(() => {
  const timer = setTimeout(() => {
    setShowMessage(false);
  }, 3000);
  
  return () => {
    clearTimeout(timer);
  };
}, []);

// ✅ Intervals
useEffect(() => {
  const interval = setInterval(() => {
    setCurrentTime(new Date());
  }, 1000);
  
  return () => {
    clearInterval(interval);
  };
}, []);

// ✅ Auto-save with cleanup
useEffect(() => {
  const saveTimer = setTimeout(() => {
    saveToLocalStorage(formData);
  }, 2000);
  
  return () => {
    clearTimeout(saveTimer); // Cancel if formData changes
  };
}, [formData]);
```

### 3. WebSockets and Connections

```jsx
// ✅ WebSocket cleanup
useEffect(() => {
  const ws = new WebSocket('ws://localhost:8080');
  
  ws.onmessage = (event) => {
    setMessages(prev => [...prev, event.data]);
  };
  
  return () => {
    ws.close();
  };
}, []);

// ✅ Event source cleanup
useEffect(() => {
  const eventSource = new EventSource('/api/stream');
  
  eventSource.onmessage = (event) => {
    setLiveData(JSON.parse(event.data));
  };
  
  return () => {
    eventSource.close();
  };
}, []);
```

### 4. Observers

```jsx
// ✅ Intersection Observer
useEffect(() => {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          setVisible(true);
        }
      });
    },
    { threshold: 0.5 }
  );
  
  const element = elementRef.current;
  if (element) {
    observer.observe(element);
  }
  
  return () => {
    if (element) {
      observer.unobserve(element);
    }
  };
}, []);

// ✅ Resize Observer
useEffect(() => {
  const resizeObserver = new ResizeObserver((entries) => {
    const { width, height } = entries[0].contentRect;
    setDimensions({ width, height });
  });
  
  const element = containerRef.current;
  if (element) {
    resizeObserver.observe(element);
  }
  
  return () => {
    if (element) {
      resizeObserver.unobserve(element);
    }
  };
}, []);
```

### 5. Animation Frames

```jsx
// ✅ Animation cleanup
useEffect(() => {
  let animationId;
  
  const animate = () => {
    setRotation(prev => (prev + 1) % 360);
    animationId = requestAnimationFrame(animate);
  };
  
  animationId = requestAnimationFrame(animate);
  
  return () => {
    cancelAnimationFrame(animationId);
  };
}, []);
```

### 6. Third-Party Libraries

```jsx
// ✅ Chart.js cleanup
useEffect(() => {
  const ctx = chartRef.current.getContext('2d');
  const chart = new Chart(ctx, {
    type: 'line',
    data: chartData,
    options: chartOptions
  });
  
  return () => {
    chart.destroy();
  };
}, [chartData]);

// ✅ Map cleanup
useEffect(() => {
  const map = new google.maps.Map(mapRef.current, mapOptions);
  const marker = new google.maps.Marker({ position, map });
  
  return () => {
    google.maps.event.clearInstanceListeners(map);
    marker.setMap(null);
  };
}, [position]);
```

### 7. Media and Streams

```jsx
// ✅ Audio cleanup
useEffect(() => {
  const audio = new Audio(audioSrc);
  
  audio.addEventListener('ended', () => {
    setPlaying(false);
  });
  
  if (isPlaying) {
    audio.play();
  }
  
  return () => {
    audio.pause();
    audio.src = ''; // Free memory
  };
}, [audioSrc, isPlaying]);

// ✅ Camera stream cleanup
useEffect(() => {
  const startCamera = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    videoRef.current.srcObject = stream;
    setStream(stream);
  };
  
  if (cameraActive) {
    startCamera();
  }
  
  return () => {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }
  };
}, [cameraActive]);
```

---

## Best Practices Summary

### Do's ✅

1. **Use onChange for input handling** - immediate, performant, follows React patterns
2. **Use derived state** instead of useEffect for simple calculations
3. **Group related state updates** in single event handlers or useReducer
4. **Always cleanup** timers, subscriptions, listeners, and connections
5. **Use cancellation patterns** (flags or AbortController) for async operations
6. **Handle race conditions** with proper cleanup in useEffect

### Don'ts ❌

1. **Don't use useEffect to update state based on other state** - causes extra renders
2. **Don't forget cleanup** - leads to memory leaks and errors
3. **Don't ignore race conditions** in async operations
4. **Don't create multiple separate states** when they're logically related
5. **Don't use useEffect for immediate user interactions** - use event handlers

### Key Principles

- **Event handlers for user interactions** - immediate response
- **useEffect for side effects** - API calls, subscriptions, cleanup
- **Derived state for calculations** - computed values, no extra state needed
- **Always clean up resources** - prevent memory leaks and errors
- **Handle async operations properly** - prevent race conditions